from telethon import TelegramClient, events
from telethon.tl.types import MessageMediaPhoto, MessageMediaDocument, MessageMediaPoll
import logging
import re
import asyncio
import os
import sys
import time
from telethon.sessions import StringSession

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

API_ID = 28776375
API_HASH = "9f2381a4d3003394c85165c0bdd7b6cb"
SESSION_STRING = "1BVtsOJIBuyc6hbqXNKuU1XIQP8vDoB0XAiCM3WiRzKjehu4fqP_J04igCptdT9b6ydR4Z60aJar4PT8h4Fx2EIxYU0AiHc73eXJcDxQob3Dbffvk14fImJck19XUP4hPPXNp2z7igNO7O4NkGdwUVY_RrCxibJFVAx8ci9tlORQvWDsFMHK1sgBvKn4RjaxglnTYUpGgLcbStjRyCxN6mxcamKbzn0h2qlHefyZTAOS1pyCKeh6HiA7znK2wC4HGoN_8K1f_0DoAuzbKLlANCLopQlTvZQXQtFJLTX9vWR8OoWjpBNVeEl4sC8thg-j9I9gFzQrFo9QQoTEP4eujqrRpd4o3Rps="

CHANNEL_MAPPING = {
    -1002391278277: -1002684192688, #chk
    -1002089916160: -1002678739357, #don to tipper
    -1002089916160: -1001700958061, #don to master 
    -1001550389952: -1002067152314,
    -1001863077816: -1002531332821, #uni to riya
    -1001237603036: -1002614906282, #bearbull to forex
    -1001322115245: -1002634331634, #kohli
    -1001693747849: -1002433251475, #raju to aman
    -1001736144739: -1002681246438, #int load to load mastdr
    -1002346858399: -1002216729602,
    -1002055712718: -1002128344220,
    -1001337837808: -1001286003149, #brand to probo
    -1001562274895: -1002584029372, #school of stock to traders army
    -1001239259365: -1002676199183, #digtial to offerzone 3.0
    -1001398719632: -1002276277599,
    -1002084539150: -1002740595413, #unicorn 
    -1001192482211: -1001638690232,#chetan 
    -1001288804936:-1001731090958,#vikrant
    -1001337837808: -1002014703761, #god father 
    -1001925619944: -1002014703761,
    -1001925619944: -1001731090958,
    -1001925619944: -1001638690232,
    -1003039215745: -1003030342862,
}

SOURCE_CHANNELS = list(CHANNEL_MAPPING.keys())
USERNAME_PATTERN = re.compile(r"@\w+", re.IGNORECASE)

message_maps = {source_id: {} for source_id in SOURCE_CHANNELS}
reverse_message_maps = {dest_id: {} for dest_id in CHANNEL_MAPPING.values()}
client = TelegramClient(StringSession(SESSION_STRING), API_ID, API_HASH)

# --- Helper to detect sticker ---
def is_sticker(message):
    if not message.media or not isinstance(message.media, MessageMediaDocument):
        return False
    for attribute in message.media.document.attributes:
        if hasattr(attribute, 'sticker') and attribute.sticker:
            return True
    return False

# --- Helper to detect voice ---
def is_voice(message):
    if not message.media or not isinstance(message.media, MessageMediaDocument):
        return False
    for attribute in message.media.document.attributes:
        if hasattr(attribute, 'voice') and attribute.voice:
            return True
    return False

# --- Helper to ignore "fairplay" messages/links ---
def should_ignore_message(message):
    text = message.text or ""
    if "fairplay" in text.lower():
        return True
    if message.entities:
        for entity in message.entities:
            if hasattr(entity, 'url') and entity.url and "https://fairplay.global/register?campaignId=offer2" in entity.url.lower():
                return True
    return False
def should_ignore_message(message):
    text = message.text or ""
    if "fairplay" in text.lower():
        return True
    if message.entities:
        for entity in message.entities:
            if hasattr(entity, 'url') and entity.url and "https://wa.link/fairplayliveho01" in entity.url.lower():
                return True
    return False
def should_ignore_message(message):
    text = message.text or ""
    if "fairplay" in text.lower():
        return True
    if message.entities:
        for entity in message.entities:
            if hasattr(entity, 'url') and entity.url and "https://t.me/+KZ0N_APxd1Q4YmZl" in entity.url.lower():
                return True
    return False
def should_ignore_message(message):
    text = message.text or ""
    if "fairplay" in text.lower():
        return True
    if message.entities:
        for entity in message.entities:
            if hasattr(entity, 'url') and entity.url and "https://fairplay.global/register?campaignId=offer2" in entity.url.lower():
                return True
    return False    
    
def should_ignore_message(message):
    text = message.text or ""

    if "mahakal" in text.lower():
        return True

    if message.entities:
        for entity in message.entities:
            if hasattr(entity, 'url') and entity.url and "Mahakal365.com" in entity.url.lower():
                return True

    return False
# --- Handle new messages ---
@client.on(events.NewMessage(chats=SOURCE_CHANNELS))
async def handle_new_message(event):
    try:
        if should_ignore_message(event.message):
            logger.info(f"Ignored message (ID: {event.message.id}) in {event.chat_id} due to 'fairplay'")
            return

        logger.info(f"Received new message (ID: {event.message.id}) in channel {event.chat_id}")
        source_channel_id = event.chat_id
        dest_channel_id = CHANNEL_MAPPING[source_channel_id]
        message = event.message

        message_text = USERNAME_PATTERN.sub("@hradmin_07", message.text) if message.text else None

        channel_message_map = message_maps[source_channel_id]
        channel_reverse_map = reverse_message_maps[dest_channel_id]

        reply_to_msg_id = None
        if message.reply_to and message.reply_to.reply_to_msg_id in channel_message_map:
            reply_to_msg_id = channel_message_map[message.reply_to.reply_to_msg_id]

        sent_message = None

        if message.media:
            if isinstance(message.media, MessageMediaPhoto):
                sent_message = await client.send_message(dest_channel_id, message_text or "", file=message.media, reply_to=reply_to_msg_id)
            elif isinstance(message.media, MessageMediaDocument):
                if is_sticker(message):
                    sent_message = await client.send_file(dest_channel_id, file=message.media.document, reply_to=reply_to_msg_id)
                elif is_voice(message):
                    sent_message = await client.send_file(dest_channel_id, file=message.media.document, voice_note=True, caption=message_text, reply_to=reply_to_msg_id)
                else:
                    sent_message = await client.send_file(dest_channel_id, file=message.media.document, caption=message_text, reply_to=reply_to_msg_id)
            elif isinstance(message.media, MessageMediaPoll):
                sent_message = await client.send_message(dest_channel_id, file=message.media, reply_to=reply_to_msg_id)
        else:
            sent_message = await client.send_message(dest_channel_id, message_text, reply_to=reply_to_msg_id)

        if sent_message:
            channel_message_map[message.id] = sent_message.id
            channel_reverse_map[sent_message.id] = message.id

    except Exception as e:
        logger.error(f"Error in handle_new_message: {e}", exc_info=True)

# --- Handle edited messages ---
@client.on(events.MessageEdited(chats=SOURCE_CHANNELS))
async def handle_edited_message(event):
    try:
        if should_ignore_message(event.message):
            logger.info(f"Ignored edited message (ID: {event.message.id}) in {event.chat_id} due to 'fairplay'")
            return

        logger.info(f"Received edited message (ID: {event.message.id}) in channel {event.chat_id}")
        source_channel_id = event.chat_id
        dest_channel_id = CHANNEL_MAPPING[source_channel_id]
        message = event.message

        message_text = USERNAME_PATTERN.sub("@hradmin_06", message.text) if message.text else None

        channel_message_map = message_maps[source_channel_id]
        if message.id not in channel_message_map:
            return

        dest_message_id = channel_message_map[message.id]
        channel_reverse_map = reverse_message_maps[dest_channel_id]

        if message.media:
            await client.delete_messages(dest_channel_id, dest_message_id)
            if isinstance(message.media, MessageMediaPhoto):
                sent_message = await client.send_message(dest_channel_id, message_text or "", file=message.media)
            elif isinstance(message.media, MessageMediaDocument):
                if is_sticker(message):
                    sent_message = await client.send_file(dest_channel_id, file=message.media.document)
                elif is_voice(message):
                    sent_message = await client.send_file(dest_channel_id, file=message.media.document, voice_note=True, caption=message_text)
                else:
                    sent_message = await client.send_file(dest_channel_id, file=message.media.document, caption=message_text)
            elif isinstance(message.media, MessageMediaPoll):
                sent_message = await client.send_message(dest_channel_id, file=message.media)
            channel_message_map[message.id] = sent_message.id
            channel_reverse_map[sent_message.id] = message.id
        else:
            await client.edit_message(dest_channel_id, dest_message_id, message_text)

    except Exception as e:
        logger.error(f"Error in handle_edited_message: {e}", exc_info=True)

# --- Handle deleted messages ---
@client.on(events.MessageDeleted(chats=SOURCE_CHANNELS))
async def handle_deleted_message(event):
    try:
        source_channel_id = event.chat_id
        dest_channel_id = CHANNEL_MAPPING[source_channel_id]
        channel_message_map = message_maps[source_channel_id]
        channel_reverse_map = reverse_message_maps[dest_channel_id]

        for msg_id in event.deleted_ids:
            if msg_id in channel_message_map:
                dest_msg_id = channel_message_map[msg_id]
                try:
                    await client.delete_messages(dest_channel_id, dest_msg_id)
                    del channel_message_map[msg_id]
                    if dest_msg_id in channel_reverse_map:
                        del channel_reverse_map[dest_msg_id]
                except Exception as e:
                    logger.error(f"Error deleting message {dest_msg_id} in channel {dest_channel_id}: {e}", exc_info=True)
    except Exception as e:
        logger.error(f"Error in handle_deleted_message: {e}", exc_info=True)

# --- Heartbeat logger ---
async def heartbeat():
    counter = 0
    while True:
        counter += 1
        logger.info(f"Bot is active. Heartbeat #{counter}. Monitoring {len(SOURCE_CHANNELS)} source channels.")
        try:
            me = await client.get_me()
            logger.info(f"Connected as: {me.first_name} (ID: {me.id})")
        except Exception as e:
            logger.error(f"Error getting user info during heartbeat: {e}")
        await asyncio.sleep(300)

# --- Main function ---
async def main():
    try:
        work_dir = os.getcwd()
        logger.info(f"Current working directory: {work_dir}")
        if sys.platform == 'win32':
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
        logger.info("Starting Telegram client with session string...")
        await client.start()
        me = await client.get_me()
        logger.info(f"Successfully connected as {me.first_name} (ID: {me.id})")
        logger.info(f"Source channels: {SOURCE_CHANNELS}")
        logger.info(f"Destination channels: {list(CHANNEL_MAPPING.values())}")
        for source_id in SOURCE_CHANNELS:
            logger.info(f"Source channel {source_id} has {len(message_maps[source_id])} cached message mappings")
        asyncio.create_task(heartbeat())
        await client.run_until_disconnected()
    except Exception as e:
        logger.error(f"Error in main function: {e}", exc_info=True)
        raise

# --- Auto restart handler ---
def auto_restart_handler():
    restart_attempts = 0
    MAX_RESTART_ATTEMPTS = 5
    RESTART_DELAY = 30
    CRITICAL_ERROR_WAIT = 300

    while True:
        try:
            asyncio.run(main())
        except Exception as e:
            restart_attempts += 1
            logger.error(f"Script encountered an error. Restart attempt {restart_attempts}: {e}")
            if restart_attempts > MAX_RESTART_ATTEMPTS:
                logger.critical(f"Maximum restart attempts ({MAX_RESTART_ATTEMPTS}) exceeded. Waiting for {CRITICAL_ERROR_WAIT} seconds before trying again.")
                time.sleep(CRITICAL_ERROR_WAIT)
                restart_attempts = 0
            logger.info(f"Waiting {RESTART_DELAY} seconds before restarting...")
            time.sleep(RESTART_DELAY)
        except KeyboardInterrupt:
            logger.info("Script terminated by user.")
            break

# --- Entry point ---
if __name__ == "__main__":
    try:
        logger.info("Starting Telegram forwarder bot")
        auto_restart_handler()
    except Exception as e:
        logger.critical(f"Unhandled exception in main startup: {e}", exc_info=True)
        sys.exit(1)
